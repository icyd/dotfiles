def table_2_record [T: table] {
    return ($T | reduce -f {} {|it, acc|
        let vals = $it | values
        if ($vals.0 | is-empty) or ($vals.1 | is-empty) {
            return $acc
        }
        $acc | upsert $vals.0 $vals.1
    })
}

export def gen_functions [] {
    if ("./kubernetes_base.nu" | path exists) {
        cp -f ./kubernetes_base.nu ./kubernetes.nu
        _gen_functions | save -a -f ./kubernetes.nu
    }
}

def _gen_functions [] {
    let operations: table<abbr: string, operation: string> = (
        [["abbr" "operation"];
            ["g" "get"]
            ["del" "delete"]
            ["d" "describe"]
        ]
    )

    let resources: table<abbr: string, resource: string, operations: list<string>> = (
        [["abbr" "resource" "operations"];
            ["" "" [g d del]]
            [no node [g]]
            [po pod [g d del]]
            [svc service [g d del]]
            [cm configmap [g d del]]
            [sec secret [g d del]]
            [dep deployment [g d del]]
            [rs replicaset [g d del]]
            [ds daemonset [g d del]]
            [sts statefulset [g d del]]
            [ing ingress [g d del]]
            [iop istiooperator [g d del]]
            [gw gateway [g d del]]
            [vs virtualservice [g d del]]
            [se serviceentry [g d del]]
            [dr destinationrule [g d del]]
            [es externalsecret [g d del]]
        ]
    )

    let resources = $resources | upsert operations {|row|
        $row.operations | each {|op|
            {abbr: $op}
        }
        | join -i $operations abbr
    }

    let envs = $"export-env {
        $env.KUBERNETES_SCHEMA_URL = $\"file:///\($env.HOME\)/.config/kubernetes-json-schema/all.json\"
        $env.KUBERNETES_RESOURCE_ABBR = (table_2_record ($resources | compact))
        $env.KUBERNETES_OPERATIONS_ABBR = ($operations)
    }"

    let commands = $resources
        | each {|res|
            $res.operations | each {|op|
                let func = match $op.operation {
                    "get" => { get },
                    "describe" => { describe },
                    "delete" => { delete },
                    _ => null,
                }
                do $func $res.abbr $res.resource

            }
    } | flatten | str join "\n\n"

    $"### Automatically generated by kubernetes utils gen_functions

### Environment variables
($envs)

### Genetared commands
($commands)
"
}

def get [] {
    return {|abbr, resource|
    let kind = if ($resource | is-empty) { "$kind" } else { $resource }
    let kind_param = if ($resource | is-empty) {
        "kind: string@\"nu-complete kube kind\""
    } else { null }

    $"# kubectl get ($resource)
export def kg($abbr) [
    ($kind_param)
    name?: string@\"nu-complete kube res via name\"
    --namespace \(-n\): string@\"nu-complete kube ns\"
    --selector\(-l\): string@\"nu-complete kube labels\"
    --verbose \(-v\)
    --wide \(-W\)
    --watch \(-w\)
    --jsonpath \(-p\): string@\"nu-complete kube jsonpath\"
    --json \(-j\)
    --yaml \(-y\)
    --neat \(-N\) # only with `--yaml` or `--json`
    --all \(-A\)
] {
    let output = \(_kg ($kind) $name
        --namespace \$namespace
        --selector $selector
        --verbose=$verbose
        --wide=$wide
        --jsonpath $jsonpath
        --json=$json
        --yaml=$yaml
        --neat=$neat
        --all=$all
        --watch=$watch
    \)

    if \($watch\) {
        hwatch -t -c -x $output
        return
    }

    if ($kind == "namespace") {
        $output | reject "namespace"
    } else {
        $output
    }
}"}
}

def delete [] {
    return {|abbr, resource|
    let kind = if ($resource | is-empty) { "$kind" } else { $resource }
    let kind_param = if ($resource | is-empty) {
        "kind: string@\"nu-complete kube kind\""
    } else { null }

    $"# kubectl delete ($resource)
export def kdel($abbr) [
    ($kind_param)
    name?: string@\"nu-complete kube res via name\"
    --namespace \(-n\): string@\"nu-complete kube ns\"
    --selector\(-l\): string@\"nu-complete kube labels\"
    --cascade: string@\"nu-complete cascade\" = \"background\"
    --dry-run: string@\"nu-complete dry-run\" = \"none\"
    --force \(-f\)
    --no-wait \(-N\)
] {
    \(_kdel ($kind) $name
        --namespace $namespace
        --selector $selector
        --cascade $cascade
        --dry-run $dry_run
        --no-wait=$no_wait
        --force=$force
    \)
}"}
}

def describe [] {
    return {|abbr, resource|
    let kind = if ($resource | is-empty) { "$kind" } else { $resource }
    let kind_param = if ($resource | is-empty) {
        "kind: string@\"nu-complete kube kind\""
    } else { null }

    $"# kubectl describe ($resource)
export def kd($abbr) [
    ($kind_param)
    name: string@\"nu-complete kube res via name\"
    --namespace \(-n\): string@\"nu-complete kube ns\"
] {
    _kd ($kind) $name --namespace $namespace
}"}
}
