def table_2_record [T: table] {
    return ($T | reduce -f {} {|it, acc|
        let vals = $it | values
        if ($vals.0 | is-empty) or ($vals.1 | is-empty) {
            return $acc
        }
        $acc | upsert $vals.0 $vals.1
    })
}

def _gen_functions [] {
    let operations: table<abbr: string, operation: string> = (
        [["abbr" "operation"];
            ["g" "get"]
            ["del" "delete"]
            ["d" "describe"]
        ]
    )

    let resources: table<abbr: string, resource: string, operations: list<string>> = (
        [["abbr" "resource" "operations" "clusterwide"];
            ["" "" [g d del] false]
            [no node [g] true]
            [po pod [g d del] false]
            [svc service [g d del] false]
            [cm configmap [g d del] false]
            [sec secret [g d del] false]
            [dep deployment [g d del] false]
            [rs replicaset [g d del] false]
            [ds daemonset [g d del] false]
            [sts statefulset [g d del] false]
            [ing ingress [g d del] false]
            [pv persistentvolume [g d del] true]
            [pvc persistentvolumeclaim [g d del] false]
            [iop istiooperator [g d del] false]
            [gw gateway [g d del] false]
            [vs virtualservice [g d del] false]
            [se serviceentry [g d del] false]
            [dr destinationrule [g d del] false]
            [es externalsecret [g d del] false]
        ]
    )

    let resources = $resources | upsert operations {|row|
        $row.operations | each {|op|
            {abbr: $op}
        }
        | join -i $operations abbr
    }

    let envs = $"export-env {
        $env.KUBERNETES_SCHEMA_URL = $\"file:///\($env.HOME\)/.config/kubernetes-json-schema/all.json\"
        $env.KUBERNETES_RESOURCE_ABBR = (table_2_record ($resources | compact))
        $env.KUBERNETES_OPERATIONS_ABBR = ($operations)
    }"

    let commands = $resources
        | each {|res|
            $res.operations | each {|op|
                let func = match $op.operation {
                    "get" => { get },
                    "describe" => { describe },
                    "delete" => { delete },
                    _ => null,
                }
                do $func $res.abbr $res.resource $res.clusterwide

            }
    } | flatten | str join "\n\n"

    $"### Automatically generated by ($env.CURRENT_FILE)

### Environment variables
($envs)

### Genetared commands
($commands)
"
}

def get [] {
    return {|abbr, resource, clusterwide|
    let kind = if ($resource | is-empty) { "$kind" } else { $resource }
    let kind_param = if ($resource | is-empty) {
        "kind: string@\"nu-complete kube kind\""
    } else { null }
    let abbr_len = $abbr | str length
    let completion = if ($abbr_len == 0) {""} else {$" via name($abbr_len)"}

    $"# kubectl get ($resource)
export def kg($abbr) [
    ($kind_param)
    name?: string@\"nu-complete kube res($completion)\"
    --context: string@\"nu-complete kube config contexts\" # context
    --namespace \(-n\): string@\"nu-complete kube ns\" # namespace
    --selector\(-l\): string@\"nu-complete kube labels\" # select by labels
    --verbose \(-v\) # verbose output
    --wide \(-W\) # output as wide format
    --watch \(-w\) # watch resources
    --jsonpath \(-p\): string@\"nu-complete kube jsonpath\" # jsonpath
    --json \(-j\) # output as json
    --yaml \(-y\) # output as yaml
    --neat \(-N\) # remove k8s metadata \(only with `--yaml` or `--json`\)
    --all \(-A\) # get all
    --show-labels \(-S\) # show labels
] {
    let output = \(_kg ($kind) $name
        --context $context
        --namespace $namespace
        --selector $selector
        --verbose=$verbose
        --wide=$wide
        --jsonpath $jsonpath
        --json=$json
        --yaml=$yaml
        --neat=$neat
        --all=$all
        --watch=$watch
        --show-labels=$show_labels
    \)

    if \($watch\) {
        hwatch -t -c -x $output
        return
    }

    $output
}"}
}

def delete [] {
    return {|abbr, resource, clusterwide|
    let kind = if ($resource | is-empty) { "$kind" } else { $resource }
    let kind_param = if ($resource | is-empty) {
        "kind: string@\"nu-complete kube kind\""
    } else { null }
    let abbr_len = $abbr | str length
    let completion = if ($abbr_len == 0) {""} else {$" via name($abbr_len)"}

    $"# kubectl delete ($resource)
export def kdel($abbr) [
    ($kind_param)
    name?: string@\"nu-complete kube res($completion)\"
    --context: string@\"nu-complete kube config contexts\" # context
    --namespace \(-n\): string@\"nu-complete kube ns\" # namespace
    --selector\(-l\): string@\"nu-complete kube labels\" # select by labels
    --cascade: string@\"nu-complete cascade\" = \"background\" # type of delete
    --dry-run: string@\"nu-complete dry-run\" = \"none\" # whether to dry-run
    --force \(-f\) # force delete
    --no-wait \(-N\) # skip waiting for deletion
] {
    \(_kdel ($kind) $name
        --context $context
        --namespace $namespace
        --selector $selector
        --cascade $cascade
        --dry-run $dry_run
        --no-wait=$no_wait
        --force=$force
    \)
}"}
}

def describe [] {
    return {|abbr, resource, clusterwide|
    let kind = if ($resource | is-empty) { "$kind" } else { $resource }
    let kind_param = if ($resource | is-empty) {
        "kind: string@\"nu-complete kube kind\""
    } else { null }
    let abbr_len = $abbr | str length
    let completion = if ($abbr_len == 0) {""} else {$" via name($abbr_len)"}

    $"# kubectl describe ($resource)
export def kd($abbr) [
    ($kind_param)
    name: string@\"nu-complete kube res($completion)\"
    --context: string@\"nu-complete kube config contexts\" # context
    --namespace \(-n\): string@\"nu-complete kube ns\" # namespace
] {
    _kd ($kind) $name --context $context --namespace $namespace
}"}
}

def main [output: path = ./kubernetes.nu] {
    let base = $"($env.FILE_PWD)/base.nu"
    $base | path exists
    if ($base | path exists) {
        print $"Copying ($base) to ($output)"
        cp -f $base $output
        print $"Appending functions to ($output)"
        _gen_functions | save -f -a $output
    } else {
        print $"File ($base) does not exists"
    }

}
